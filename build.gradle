if ( !project.hasProperty( 'typeOfRelease' ) || ( !project.ext.typeOfRelease.equalsIgnoreCase( 'SNAPSHOT' ) && !project.ext.typeOfRelease.equalsIgnoreCase( 'RELEASE' ) ) ) {
	println( "No valid type of release selected. Please add parameter 'typeOfRelease' with values 'SNAPSHOT' for snapshot release or 'RELEASE' for productive release." )
}

buildscript {
	repositories {
		if ( project.hasProperty( 'artifactRepositoryUrl' ) && project.ext.artifactRepositoryUrl != null && project.ext.artifactRepositoryUrl.trim() != '' ) {
			maven {
				url "${artifactRepositoryUrl}/${artifactRepositoryPathPublic}"
				credentials {
					username = "${artifactRepositoryDeploymentUser}"
					password = "${artifactRepositoryDeploymentUserPassword}"

				}
			}
		}
		mavenCentral()
		mavenLocal()
	}
	dependencies {
		classpath "${project.ext.'gav.gradlePlugin.org.liquibase.liquibase-gradle-plugin'}"
		classpath "${project.ext.'gav.gradlePlugin.org.sonarsource.scanner.gradle.sonarqube-gradle-plugin'}"
	}
}

apply plugin: 'base'
apply plugin: 'idea'
apply plugin: 'org.sonarqube'

allprojects {
	configurations {
		testArtifacts.extendsFrom testRuntime
	}

	apply plugin: 'java-library'
	apply plugin: 'jacoco'
	apply plugin: 'maven-publish'

	sourceCompatibility = "${project.ext.'java.sourcecompatibility'}"
	targetCompatibility = "${project.ext.'java.targetcompatibility'}"
	[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

	repositories {
		if ( project.hasProperty( 'artifactRepositoryUrl' ) && project.ext.artifactRepositoryUrl != null && project.ext.artifactRepositoryUrl.trim() != '' ) {
			maven {
				url "${project.ext.'artifactRepositoryUrl'}/${project.ext.'artifactRepositoryPathPublic'}"
				credentials {
					username = "${project.ext.'artifactRepositoryDeploymentUser'}"
					password = "${project.ext.'artifactRepositoryDeploymentUserPassword'}"

				}
			}
		}
		mavenCentral()
		mavenLocal()
	}

	dependencies {
		// Adding dependencies here will add the dependencies to each subproject.
		testImplementation "${project.ext.'gav.lib.junit.junit'}"
		testImplementation "${project.ext.'gav.lib.nl.jqno.equalsverifier.equalsverifier'}"
		testImplementation "${project.ext.'gav.lib.org.hamcrest.hamcrest-library'}"
		testImplementation "${project.ext.'gav.lib.org.junit.jupiter.junit-jupiter-api'}"
		testImplementation "${project.ext.'gav.lib.org.mockito.mockito-core'}"
		testImplementation "${project.ext.'gav.lib.org.mockito.mockito-junit-jupiter'}"

		testRuntimeOnly "${project.ext.'gav.lib.org.junit.jupiter.junit-jupiter-engine'}"
		testRuntimeOnly "${project.ext.'gav.lib.org.junit.vintage.junit-vintage-engine'}"
	}

	tasks.withType( Test ) {
		useJUnitPlatform()

		reports {
			junitXml.required = true
			html.required = true
		}
	}

	jacoco {
		toolVersion = project.ext.'util.org.jacoco.jacoco.version'
	}

	jacocoTestReport {
		reports {
			html.required.set( true )
			xml.required.set( true )
			xml.outputLocation.set( file("${buildDir}/reports/jacoco.xml") )
		}
	}

	sonarqube {
		properties {
			property "sonar.java.coveragePlugin", "jacoco"
			property "sonar.coverage.jacoco.xmlReportPath", "${buildDir}/reports/jacoco.xml"
		}
	}

	String mavenArtifactId = name
	group = project.ext.mavenGroupId
	version = project.ext.mavenVersion
	// Append suffix '-SNAPSHOT' if it is a snapshot release...
	if ( !project.hasProperty( 'typeOfRelease' ) || project.ext.typeOfRelease.equalsIgnoreCase( 'SNAPSHOT' ) ) {
		version += '-SNAPSHOT'
	}

	task sourcesJar( type: Jar, dependsOn: classes, description: 'Creates a jar from the source files.' ) {
		archiveClassifier.set( 'sources' )
		from sourceSets.main.allSource
	}

	task javadocJar( type: Jar, dependsOn: 'javadoc', description: 'Creates a jar from the JavaDoc files.' ) {
		from javadoc.destinationDir
		archiveClassifier.set( 'javadoc' )
	}

	task testJar(type: Jar, dependsOn: 'jar', description: 'Creates a test jar file.') {
		archiveClassifier.set( 'test' )
		from sourceSets.test.output
	}

	artifacts {
		archives jar
		archives javadocJar
		archives sourcesJar
		testArtifacts testJar
	}

	publishing {
		def repoKey = ''

		if ( !project.hasProperty( 'typeOfRelease' ) || project.ext.typeOfRelease.equalsIgnoreCase( 'SNAPSHOT' ) ) {
			repoKey = 'snapshot'
		}
		else if ( project.ext.typeOfRelease.equalsIgnoreCase( 'RELEASE' ) ) {
			repoKey = 'release'
		}

		if( repoKey != '' ) {
			repositories {
				if ( project.hasProperty( 'artifactRepositoryUrl' ) && project.ext.artifactRepositoryUrl != null && project.ext.artifactRepositoryUrl.trim() != '' ) {
					maven {
						name repoKey
						credentials {
							username "${project.ext.'artifactRepositoryDeploymentUser'}"
							password "${project.ext.'artifactRepositoryDeploymentUserPassword'}"
						}
						if (!project.hasProperty('typeOfRelease') || project.ext.typeOfRelease.equalsIgnoreCase('SNAPSHOT')) {
							url "${project.ext.'artifactRepositoryUrl'}/${project.ext.'artifactRepositoryPathSnapshots'}"
						} else if (project.ext.typeOfRelease.equalsIgnoreCase('RELEASE')) {
							url "${project.ext.'artifactRepositoryUrl'}/${project.ext.'artifactRepositoryPathReleases'}"
						}
					}
				}
			}
		}

		publications {
			mavenJava( MavenPublication ) {
				from components.java

				artifact sourcesJar
				artifact javadocJar
				artifact testJar
			}
		}
	}

	task createFolders( description: 'Creates the source folders if they do not exist.' ) doLast {
		sourceSets*.allSource*.srcDirs*.each { File srcDir ->
			if ( !srcDir.isDirectory() ) {
				println "Creating source folder: ${srcDir}"
				srcDir.mkdirs()
			}
		}
	}
}

// Print build information...
println '***********************************************************'
println '* Build environment information:'
println '* =============================='
println "* Gradle wrapper version: ${GradleVersion.current().getVersion()}"
println "* JDK version: ${JavaVersion.current()} (${System.getProperty( 'java.version' )})"
println "* Source compatibility: ${project.sourceCompatibility}"
println "* Target compatibility: ${project.targetCompatibility}"
println '*'
println '* MAVEN artifact information:'
println '* ==========================='
println "* Group ID: ${project.group}"
println "* Artifact ID: ${project.name}"
println "* Version: ${project.version}"
println '***********************************************************'
